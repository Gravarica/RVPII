---
title: "Analiza policijskih akcija na teritoriji grada Sijetla"
author: "Miloš Gravara"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.align = "center")
```
### Skup podataka o policijskim akcijama na teritoriji grada Sijetla

Ovaj skup podataka sadrži informacije o pozivima policiji i odgovarajućim policijskim akcijama u Sijetlu. Kolone u skupu podataka su sledeće:
1. **CAD.Event.Number** - Jedinstveni identifikacioni broj događaja. 
2. **Event.Clearance.Description** - Policijski kako je događaj završen.
3. **Call.Type** - Tip poziva sa 10 različitih vrednosti (911, Alarm, Onview...)
4. **Priority** - Prioritet poziva sa vrednostima od 1 (najmanjeg prioriteta) do 9 (najvišeg)
5. **Initial.Call.Type** - Prvobitna klasifikacija poziva od strane primaoca poziva u 911 centru, sa 325 različitih vrednosti 
6. **Final.Call.Type** - Konačna klasifikacija poziva od strane policijskog službenika nakon pregleda, sa 431 različitom vrednošću
7. **Original.Time.Queued** - Vreme kada je poziv zabeležen
8. **Arrived.Time** - Vreme kada je policija stigla na lice mesta. 
9. **Precinct** - Policijska stanica u Sijetlu 
10. **Sector** - Policijski sektor 
11. **Beat** - Teritorija i vreme tokom kojeg policijski službenih patrolira 
12. **Blurred_Longitude** - Geografska dužina događaja
13. **Blurred_Latitude** - Geografska širina događaja

Ovaj skup podataka pruža detaljne informacije o svim pozivima koje je primila policija, uključujući tipove poziva, prioritete, vremena poziva i dolaska policije, kao i geografske lokacije događaja (zamaskirane). Takođe uključuje početnu i konačnu klasifikaciju svakog poziva, što omogućava analizu kako se incidenti klasifikuju i rešavaju.

### Instalacija neophodnih paketa
``` {r eval=T, results = 'hide', include = FALSE}
#install.packages("dplyr")
#install.packages("ggplot2")
#install.packages("knitr")
#install.packages("ggmap")
#install.packages("sparklyr")
```
### Ucitavanje i priprema neophodnih biblioteka
``` {r eval=T, results='hide', include=FALSE}
library(dplyr)
library(ggplot2)
library(knitr)
library(ggmap)
library(sparklyr)

#spark_install(version = "3.5")
conf <- spark_config()
conf$`sparklyr.shell.driver-memory` <- "16G"
conf$spark.memory.fraction <- 0.9

sc <- spark_connect(master = "local", 
                    version = "3.5",
                    config = conf)
```
### Ucitavanje podataka

S obzirom na veličinu skupa podataka (1.1GB), podaci se učitavaju i dalje transformišu uz pomoć Apache Spark alata.

``` {r eval = T, results = 'hold'}
schema <- list(
  CAD.Event.Number = "character",
  Event.Clearance.Description = "character",
  Call.Type = "character",
  Priority = "character",
  Initial.Call.Type = "character",
  Final.Call.Type = "character",
  Original.Time.Queued = "character",
  Arrived.Time = "character",
  Precinct = "character",
  Sector = "character",
  Beat = "character",
  Blurred_Longitude = "numeric",
  Blurred_Latitude = "numeric"
)

df <- spark_read_csv(sc, name = "police_calls", path = "Call_Data.csv", header = TRUE, columns = schema)
```

### Priprema podataka za analizu

Kako bi se mogla vršiti adekvatna analiza podataka neophodno je uraditi nekoliko transformacija na početnom skupu podataka: 

* Izbacivanje svih nepostojećih vrednosti iz skupa 

``` {r eval=T, results='hold'}
df_clean <- df %>% na.omit()
```

``` {r}
df_clean %>% summarise(
  min_original_time = min(Original_Time_Queued, na.rm = TRUE),
  max_original_time = max(Original_Time_Queued, na.rm = TRUE),
  min_arrived_time = min(Arrived_Time, na.rm = TRUE),
  max_arrived_time = max(Arrived_Time, na.rm = TRUE)
) %>% collect()
```

``` {r eval = T, results='hold'}
df_clean <- df_clean %>%
  mutate(
    Original_Time_Queued = to_timestamp(Original_Time_Queued, "MM/dd/yyyy hh:mm:ss a"),
    Arrived_Time = to_timestamp(Arrived_Time, "MM/dd/yyyy hh:mm:ss a")
  )
```

``` {r}
df_clean <- df_clean %>%
  filter(!is.na(Original_Time_Queued) & !is.na(Arrived_Time) & Original_Time_Queued < Arrived_Time)
```

### Vizualizacija raspodele po pojedinacnim obelezjima i odnosa izmedju obelezja

##### Vizualizacija raspodele po policijskim upravama: 

``` {r}
precinct_counts <- df_clean %>%
  group_by(Precinct) %>%
  summarise(Count = n())

ggplot(precinct_counts, aes(x = Precinct, y = Count, fill = Precinct)) +
  geom_bar(stat = "identity") +
  labs(title = "Prikaz raspodele po policijskim upravama",
       x = "Policijska uprava",
       y = "Broj pojava",
       fill = "Precinct")
```
* Moze se primetiti da je najvise policijskih reakcija bilo u severnoj i zapadnoj policijskoj upravi.

##### Vizualizacija raspodele po nacinu razresavanja slucaja:

``` {r}
clearence_counts <- df_clean %>%
  group_by(Event_Clearance_Description) %>%
  summarise(Count = n())

ggplot(clearence_counts, aes(x = Event_Clearance_Description, y = Count, fill = Event_Clearance_Description)) +
  geom_bar(stat = "identity") +
  labs(title = "Prikaz raspodele po nacinu razresenja slucaja",
       x = "Rezolucija",
       y = "Broj pojava",
       fill = "Clearence")
```

##### Vizualizacija raspodele geografske sirine i duzine

* Pravljenjem histograma za lokacijske podatke, može se primetiti da postoji određeni broj događaja koji imaju pogrešno specificiranu geografsku širinu ili dužinu. Naredni isečak koda prikazuje raspodele vrednosti geografske širine i dužine, kao i sređivanje tih vrednosti kako bi odgovarale koordinatama grada Sijetla. 

``` {r eval=T, results='hold'}
ggplot(data = df_clean, aes(x = Blurred_Longitude)) +
  geom_histogram(bins = 30, fill = "skyblue", color = "black") +
  labs(title = "Histogram geografske širine",
       x = "Geografksa širina",
       y = "Frekvencija")
```

``` {r eval=T, results='hold'}
ggplot(data = df_clean, aes(x = Blurred_Latitude)) +
  geom_histogram(bins = 30, fill = "skyblue", color = "black") +
  labs(title = "Histogram geografske dužine",
       x = "Geografksa dužina",
       y = "Frekvencija")
```

* Moze se primetiti na histogramima da postoji odredjeni broj entiteta koji imaju pogresno unete koordinate geografske sirine i duzine. S obzirom na to da ne postoji prevelik broj ovakvih entiteta, oni se mogu izbaciti iz skupa podataka. To se moze uraditi na sledeci nacin:

``` {r}
df_clean_ll <- df_clean %>% filter(Blurred_Latitude >= 47 & Blurred_Latitude <= 48 & Blurred_Longitude >= -123 & Blurred_Longitude <= -122)
```

##### Histogrami raspodele geografske sirine i duzine za ociscene vrednosti

``` {r}
ggplot(data = df_clean_ll, aes(x = Blurred_Longitude)) +
  geom_histogram(bins = 30, fill = "skyblue", color = "black") +
  labs(title = "Histogram geografske širine",
       x = "Geografksa širina",
       y = "Frekvencija")
```

``` {r}
ggplot(data = df_clean_ll, aes(x = Blurred_Longitude)) +
  geom_histogram(bins = 30, fill = "skyblue", color = "black") +
  labs(title = "Histogram geografske širine",
       x = "Geografksa širina",
       y = "Frekvencija")
```

* Raspodela ovih vrednosti se moze prikazati i na mapi, uz upotrebu **ggmap** biblioteke i stadiamaps API kljuca, sto prikazuje sledeci isecak koda:

``` {r eval = FALSE}
# Postavljanje vrednosti API kljuca
register_stadiamaps("04c1350e-f51f-4265-b458-ad6b6a3192bb", write = TRUE)
# Kreiranje mape Sijetla
seattle <- c(left = -122.45, bottom = 47.48, right = -122.2, top = 47.73)
seattle_map <- get_stadiamap(seattle, zoom = 18)
# Plotovanje mape
ggmap(seattle_map) +
 geom_point(data = df_clean_ll, aes(x = Blurred_Longitude, y = Blurred_Latitude,  color = Final_Call_Type))
 labs(title = "Seattle Crime Map",
      x = "Longitude",
      y = "Latitude",
 color = "Final Call Type")
```

``` {r}
include_graphics("Slike/PointsOnTheMap.png")
```

##### Vizualizacija raspodele kategorija

* Sledeca stvar koja se mora uzeti u obzir jesu inicijalne i finalne kategorije poziva predstavljene kolonama Initial_Call_Type i Final_Call_Type. S obzirom na to da Initial_Call_Type sadrzi 287 razlicitih kategorija, a Final_Call_Type 402 razlicite kategorije, ideja je da se ove kategorije grupisu u natkategorije kako bi se podaci lakse analizirali i vizualizovali. Sledeci isecak koda prikazuje funkciju `map_call_types` kojom se vrsi grupisanje ovih kategorija: 

``` {r}
df_collected <- df_clean_ll %>% collect()
print(length(unique(df_collected$Initial_Call_Type)))
print(length(unique(df_collected$Final_Call_Type)))
```
* Sledeci isecak koda prikazuje grupisanje inicijalnih kategorija poziva u natkategorije: 

``` {r}
df_clean_ll <- df_clean_ll %>%
  mutate(Initial_Category = case_when(
    grepl("ASLT|Assault|ASSAULT|ASSAULTS|HARRASMENT|THREAT|THREATS|WEAPON|GUN|PANHANDLING|HARASSMENT|VIOLENT", Initial_Call_Type) ~ "Assaults and Threats",
    grepl("TRAFFICING|SEX|RAPE|PORNOGRAPHY|PROSTITUTION|LEWD|PROWLER", Initial_Call_Type) ~ "Sex Offenses",
    grepl("NARCOTICS|DRUGS|MARIJUANA|OVERDOSE|OD|LIQUOR|DETOX|INTOX|LIQ", Initial_Call_Type) ~ "Narcotics",
    grepl("HARBOR|ANIMAL|GAMBLING|WATER|TREES|NORAD|STADIUM|ILLEGAL DUMPING|SLEEPER|HAZ|BIAS|NUISANCE|URINATING|HOSPITAL|PHONE|CROWD|EVENT|DEMONSTRATIONS|DISTURBANCE|UNUSUAL|NOISE|POWER|LANDLINE|LITTERING", Initial_Call_Type) ~ "Civil incidents and security",
    grepl("DOA|SHOTS|CASUALTY|FELONY|SUSPICIOUS|ESCAPE|FIRE|PURSUIT|SWAT|SHOOTING|SUICIDE|HOSTAGE|HOMICIDE", Initial_Call_Type) ~ "Emergency and Critical incidents",
    grepl("ROBBERY|BURGLARY|PROPERTY|THEFT|BREAKING|SHOPLIFT|ARSON|TRESPASS|BURG|BURN|EXPLOSION|FRAUD", Initial_Call_Type) ~ "Property Crimes",
    grepl("ALARM|ORDER|INSPECTION|WATCH", Initial_Call_Type) ~ "Alarm and Security",
    grepl("ASSIST|CHECK|HELP|ASSIGNED|PATROL", Initial_Call_Type) ~ "Assistance and Checks",
    grepl("DOMESTIC|ABUSE|CUSTODIAL|ARGUMENTS|DV", Initial_Call_Type) ~ "Domestic Violence",
    grepl("Traffic|VIOLATIONS|ACCIDENT|MVC|CAR|DUI|TRAF|ROAD|VEHICLE|DUI|ACC|HIT AND RUN|", Initial_Call_Type) ~ "Traffic Incident",
    grepl("MISSING|AWOL|FOUND|RUNAWAY|ABDUCTION|KIDNAP|CHILD|JUVENILE|LOST|AMBER|A.W.O.L.", Initial_Call_Type) ~ "Missing Persons",
    grepl("OBS", Initial_Call_Type) ~ "Observation",
    grepl("CANCELLED|NO ANSWER|OUT AT RANGE", Initial_Call_Type) ~ "No action",
    TRUE ~ "Other"
  ))
```

* Primena i na finalnu kategoriju poziva: 

``` {r}
df_clean_ll <- df_clean_ll %>%
  mutate(Final_Category = case_when(
    grepl("ASLT|Assault|ASSAULT|ASSAULTS|HARRASMENT|THREAT|THREATS|WEAPON|GUN|PANHANDLING|HARASSMENT|VIOLENT", Final_Call_Type) ~ "Assaults and Threats",
    grepl("TRAFFICING|SEX|RAPE|PORNOGRAPHY|PROSTITUTION|LEWD|PROWLER", Final_Call_Type) ~ "Sex Offenses",
    grepl("NARCOTICS|DRUGS|MARIJUANA|OVERDOSE|OD|LIQUOR|DETOX|INTOX|LIQ", Final_Call_Type) ~ "Narcotics",
    grepl("HARBOR|ANIMAL|GAMBLING|WATER|TREES|NORAD|STADIUM|ILLEGAL DUMPING|SLEEPER|HAZ|BIAS|NUISANCE|URINATING|HOSPITAL|PHONE|CROWD|EVENT|DEMONSTRATIONS|DISTURBANCE|UNUSUAL|NOISE|POWER|LANDLINE|LITTERING", Final_Call_Type) ~ "Civil incidents and security",
    grepl("DOA|SHOTS|CASUALTY|FELONY|SUSPICIOUS|ESCAPE|FIRE|PURSUIT|SWAT|SHOOTING|SUICIDE|HOSTAGE|HOMICIDE", Final_Call_Type) ~ "Emergency and Critical incidents",
    grepl("ROBBERY|BURGLARY|PROPERTY|THEFT|BREAKING|SHOPLIFT|ARSON|TRESPASS|BURG|BURN|EXPLOSION|FRAUD", Final_Call_Type) ~ "Property Crimes",
    grepl("ALARM|ORDER|INSPECTION|WATCH", Final_Call_Type) ~ "Alarm and Security",
    grepl("ASSIST|CHECK|HELP|ASSIGNED|PATROL", Final_Call_Type) ~ "Assistance and Checks",
    grepl("DOMESTIC|ABUSE|CUSTODIAL|ARGUMENTS|DV", Final_Call_Type) ~ "Domestic Violence",
    grepl("Traffic|VIOLATIONS|ACCIDENT|MVC|CAR|DUI|TRAF|ROAD|VEHICLE|DUI|ACC|HIT AND RUN|", Final_Call_Type) ~ "Traffic Incident",
    grepl("MISSING|AWOL|FOUND|RUNAWAY|ABDUCTION|KIDNAP|CHILD|JUVENILE|LOST|AMBER|A.W.O.L.", Final_Call_Type) ~ "Missing Persons",
    grepl("OBS", Final_Call_Type) ~ "Observation",
    grepl("CANCELLED|NO ANSWER|OUT AT RANGE", Final_Call_Type) ~ "No action",
    TRUE ~ "Other"
  ))
```

* S obzirom na to da je moguce da se desi da inicijalna kategorizacija od strane 911 operatera ne odgovara finalnoj kategorizaciji dogadjaja od strane policajca, sledeci dijagram prikazuje raspodelu slucajeva kada je finalna kategorizacija odgovarala incijalnoj i obrnuto: 

``` {r}
same_diff_counts <- df_clean_ll %>%
  group_by(Same_Category = ifelse(Initial_Category == Final_Category, "Ista", "Razlicita")) %>%
  summarise(Count = n())

# Stubicasti dijagram za prikaz vrednosti
ggplot(same_diff_counts, aes(x = Same_Category, y = Count, fill = Same_Category)) +
  geom_bar(stat = "identity") +
  labs(title = "Poredjenje inicijalne i finalne kategorije",
       x = "Kategorija",
       y = "Broj pojava",
       fill = "Category")
```

* Raspodela finalnih kategorizacija je prikazana na narednom stubicastom dijagramu: 

``` {r Raspodela inicijalnih kategorija nakon grupisanja}
initial_category_counts <- df_clean_ll %>%
  group_by(Initial_Category) %>%
  summarise(Count = n())

ggplot(initial_category_counts, aes(x = reorder(Initial_Category, -Count), y = Count, fill = Initial_Category)) +
  geom_bar(stat = "identity") +
  labs(title = "Raspodela inicijalnih kategorizacija",
       x = "Inicijalna Kategorija",
       y = "Broj pojava") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

``` {r Raspodela finalnih kategorija nakon grupisanja}
final_category_counts <- df_clean_ll %>%
  group_by(Final_Category) %>%
  summarise(Count = n())

ggplot(final_category_counts, aes(x = reorder(Final_Category, -Count), y = Count, fill = Final_Category)) +
  geom_bar(stat = "identity") +
  labs(title = "Raspodela finalnih kategorizacija",
       x = "Finalna Kategorija",
       y = "Broj pojava") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

##### Vizualizacija finalne kategorije prijave spram geografske sirine i duzine

``` {r Odnos Finalne kategorije i geografske lokacije}
ggplot(df_prepared, aes(x = Blurred_Longitude, y = Blurred_Latitude, color = Final_Category)) +
  geom_point(alpha = 0.6) +  
  labs(title = "Visualization odnosa finalne kategorije i lokacije prijave",
       x = "Geografska sirina",
       y = "Geografska duzina",
       color = "Finalna kategorija") +
  theme_minimal() +
  theme(legend.position = "bottom")
```

* Na dijagramu iznad se moze videti da raspodela kategorija prekrsaja i zlocina ne zavisi od geografske sirine i duzine, stoga nema preteranog smisla pokusavati vrsiti klasterizaciju nad ovim vrednostima.

##### Vizualizacija odnosa sektora i lokacije prijave:

``` {r Odnos sektora grada Sijetla i geografske lokacije}
ggplot(df_prepared, aes(x = Blurred_Longitude, y = Blurred_Latitude, color = Sector)) +
  geom_point(alpha = 0.6) +  
  labs(title = "Visualization odnosa sektora i lokacije prijave",
       x = "Geografska sirina",
       y = "Geografska duzina",
       color = "Sektor") +
  theme_minimal() +
  theme(legend.position = "bottom")
```

##### Vizualizacija odnosa policijske uprave i lokacije prijave

``` {r Odnos policijske uprave i geografske lokacije}
ggplot(df_prepared, aes(x = Blurred_Longitude, y = Blurred_Latitude, color = Precinct)) +
  geom_point(alpha = 0.6) +  
  labs(title = "Visualization odnosa policijske uprave i lokacije prijave",
       x = "Geografska sirina",
       y = "Geografska duzina",
       color = "Policijska uprava") +
  theme_minimal() +
  theme(legend.position = "bottom")
```

* Sa druge strane, moze se uvideti da su odgovarajuce policijske uprave odgovorne za reakcije na odredjenim teritorijama grada, sto ga ovaj skup podataka cini pogodnim za klasterizaciju spram vrednosti tih obelezja. 

##### Priprema podataka za klasfikaciju

* Jedna od mogucnosti za klasifikaciju jeste procena brzine policijske reakcije na osnovu prijavljenog dogadjaja. S obzirom na to da mnogi faktori mogu da uticu na brzinu reakcije, poput geografske lokacije, sektora policijske stanice, kategorije poziva, aktivne jedinice patroliranja, prioriteta i inicijalnog vremena, moguce je na osnovu obelezja Arrival.Time, labelirati podatke na osnovu da li je reakcija bila brza ili nije, pa vrsiti binarnu klasifikaciju. Kako bi se moglo utvrditi sta je brza reakcija, a sta ne, najpre ce se skicirati histogram petominutnih intervala kako bi se uvidela raspodela pojava. 

* Racunanje vremena odziva na dogadjaj: 
``` {r}
df_times <- df_clean_ll %>%
  mutate(
    Response_Time = (unix_timestamp(Arrived_Time) - unix_timestamp(Original_Time_Queued)) / 60
  )
```

* Plotovanje histograma kako bi se uvidela raspodela vremena odziva: 

``` {r}
# Plot histogram with 5-minute bins
df_times <- df_times %>% filter(Response_Time >= 0 & Response_Time <= 1000)

ggplot(df_times, aes(x = Response_Time)) +
  geom_histogram(binwidth = 10, fill = "skyblue", color = "black") +
  labs(title = "Distribution of Response Times",
       x = "Response Time (minutes)",
       y = "Frequency")
```

* Kako bi se izvrsila binarna klasifikacija, kreirano je novo obelezje (labela) `Response_Speed` koje ima vrednosti 'Fast' i 'Slow'. Vrednosti ovog obelezja se dodeljuju na osnovu medijalne vrednosti vremena odziva - `Response_Time`. Sve pojave koje imaju vreme odziva manje od medijalne ce imati vrednost labele `Response_Speed` - 'Fast', dok ce ostale pojave imati vrednost - 'Slow'. Sledeci kod prikazuje kreiranje ovog obelezja u skupu podataka: 

``` {r}
dft <- df_times %>% collect()
median_value <- median(dft$Response_Time)
df_prepared <- df_times %>%
  mutate(Response_Speed = if_else(Response_Time <= median_value, 1, 0))
```

##### Prikaz raspodele brzine odziva

``` {r}
response_speeds <- df_prepared %>%
  group_by(Response_Speed) %>%
  summarise(Count = n())

ggplot(response_speeds, aes(x = Response_Speed, y = Count, fill = Response_Speed)) +
  geom_bar(stat = "identity") +
  labs(title = "Raspodela brzina odziva",
       x = "Brzina odziva",
       y = "Broj pojava",
       fill = "Response_Speed")
```

##### Vizualizacija odnosa izmedju prediktorskih obelezja i ciljnog obelezja:

* Naredna sekcija ima za cilj da prikaze kako razlicite vrednosti prediktorskih obelezja uticu na brzinu odziva policijske jedinice na poziv. Naredni isecak koda ima za cilj da prikaze kako prioritet, inicijalna kategorija poziva, lokacija i sektor uticu na vremena odziva.  

``` {r}
ggplot(df_prepared, aes(x = Priority, y = Response_Time)) +
  geom_boxplot() +
  labs(title = "Response Time vs. Priority", x = "Priority", y = "Response Time")

ggplot(df_prepared, aes(x = Initial_Category, y = Response_Time)) +
  geom_boxplot() +
  labs(title = "Response Time vs. Initial Category", x = "Initial Category", y = "Response Time") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggplot(df_prepared, aes(x = Blurred_Longitude, y = Blurred_Latitude, color = Response_Speed)) +
  geom_point() +
  labs(title = "Response Speed vs. Location", x = "Longitude", y = "Latitude", color = "Response Time")

ggplot(df_prepared, aes(x = Sector, y = Response_Time)) +
  geom_boxplot() +
  labs(title = "Response Time vs. Sector", x = "Sector", y = "Response Time") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

### Klasifikacija

#### Priprema skupa podataka za obucavanje

* Naredni isecak koda prikazuje podelu skupa podataka na trening i validacioni set:

``` {r Priprema skupa podataka}
df_prepared_split <- df_prepared %>%
  select(Response_Time, Response_Speed, Sector, Precinct, Initial_Category, Blurred_Longitude, Blurred_Latitude, Priority) %>%
  sdf_random_split(training = 0.8,
                   test = 0.2,
                   seed = 100)
```

#### Kreiranje razlicitih klasifikacionih modela sa razlicitim hiperparametrima:

##### Logisticka regresija

``` {r Priprema modela logisticke regresije}
# Logistic Regression
log_pipeline <- sc %>% 
  ml_pipeline() %>%
  ft_r_formula(Response_Speed ~ .) %>%
  ml_logistic_regression()

param_grid <- list(
  logistic_regression = list(reg_param = c(0.01, 0.1, 1))
)

lr_evaluator <- ml_binary_classification_evaluator(x = sc, metricName = "areaUnderROC")

# Kros-validacija
logistic_cv <- ml_cross_validator(
  x = sc, 
  estimator = log_pipeline,
  estimator_param_maps = param_grid,
  evaluator = lr_evaluator,
  num_folds = 5
)

print(logistic_cv)

model_cv <- ml_fit(
  x = logistic_cv,
  dataset = df_prepared_split$training
)

cv_metrics <- ml_validation_metrics(model_cv)

cv_metrics %>% 
  ggplot(aes(reg_param_1, areaUnderROC)) + 
  geom_line() + 
  geom_smooth()
```

``` {r Testiranje performansi modela}
# Na osnovu grafa se utvrdjuje da je model sa parametrom regularizacije 0.01 najbolji
lmodel <- ml_logistic_regression(
  df_prepared_split$training,
  Response_Speed ~ .,
  reg_param = 0.01
)

lrmx <- lmodel %>% 
  ml_predict(df_prepared_split$test) %>% 
  ml_metrics_binary()
```

##### Random Forest algoritam 

``` {r Priprema random forest modela}
# Random Forest
rf_pipeline <- sc %>% 
  ml_pipeline() %>%
  ft_r_formula(Response_Speed ~ .) %>%
  ml_random_forest_classifier()

rf_grid <- list(
  random_forest_classifier = list(  
    num_trees = c(10, 30, 50)
  )
)

rf_evaluator = ml_binary_classification_evaluator(x = sc, metricName = "areaUnderROC")

# Kros-validacija
rf_cv <- ml_cross_validator(
  x = sc, 
  estimator = rf_pipeline,
  estimator_param_maps = rf_grid,
  evaluator = rf_evaluator, 
  num_folds = 5
)

model_rf_cv <- ml_fit(
  x = rf_cv,
  dataset = df_prepared_split$training
)

rf_cv_metrics <- ml_validation_metrics(model_rf_cv)

rf_cv_metrics %>% 
  ggplot(aes(num_trees_1, areaUnderROC)) + 
  geom_line() + 
  geom_smooth()
```

``` {r Testiranje performansi modela}
# Izbor najboljeg modela

rfmodel <- ml_random_forest_classifier(
  df_prepared_split$training,
  Response_Speed ~ .,
  num_trees = 50
)

rfmx <- rfmodel %>% 
  ml_predict(df_prepared_split$test) %>% 
  ml_metrics_binary()
```

##### Decision Trees

``` {r Priprema modela stabla odlucivanja}
dt_pipeline <- sc %>% 
  ml_pipeline() %>%
  ft_r_formula(Response_Speed ~ .) %>%
  ml_decision_tree_classifier()

dt_grid <- list(
  decision_tree_classifier = list(
    max_depth = c(3, 5, 10)
  )
)

dt_evaluator <- ml_binary_classification_evaluator(x = sc, metricName = "areaUnderROC")

# Kros-validacija
dt_cv <- ml_cross_validator(
  x = sc, 
  estimator = dt_pipeline,
  estimator_param_maps = dt_grid,
  evaluator = dt_evaluator, 
  num_folds = 5
)

model_dt_cv <- ml_fit(
  x = dt_cv,
  dataset = df_prepared_split$training
)

dt_cv_metrics <- ml_validation_metrics(model_dt_cv)

dt_cv_metrics %>% 
  ggplot(aes(max_depth_1, areaUnderROC)) + 
  geom_line() + 
  geom_smooth()
```

``` {r Testiranje performansi modela}
# Izbor najpovoljnijeg modela

dtmodel <- ml_decision_tree_classifier(
  df_prepared_split$training,
  Response_Speed ~ .,
  max_depth = 5
)

dtmx <- dtmodel %>% 
  ml_predict(df_prepared_split$test) %>% 
  ml_metrics_binary()

```

#### Ocenjivanje performansi klasifikacije razlicitih metoda:

``` {r}

metrics_df <- data.frame(
  model = c("Logistic Regression", "Random Forest", "Decision Tree"),
  auc_roc = NA, 
  pr_auc = NA
)

# Fill in the metrics for each model
metrics_df[1, "auc_roc"] <- lrmx$.estimate[1]
metrics_df[1, "pr_auc"] <- lrmx$.estimate[2]

metrics_df[2, "auc_roc"] <- rfmx$.estimate[1]
metrics_df[2, "pr_auc"] <- rfmx$.estimate[2]

metrics_df[3, "auc_roc"] <- dtmx$.estimate[1]
metrics_df[3, "pr_auc"] <- dtmx$.estimate[2]

print(metrics_df)

ggplot(metrics_df, aes(x = model, y = auc_roc, fill = model)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "ROC-AUC Comparison", y = "ROC-AUC") +
  theme_minimal()

ggplot(metrics_df, aes(x = model, y = pr_auc, fill = model)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "PR-AUC Comparison", y = "PR-AUC") +
  theme_minimal()
```

### Klasterizacija

#### Priprema skupa podataka i parametara za klasterizaciju

``` {r Priprema skupa podataka i parametara za klasterizaciju}
df_clustering <- df_prepared %>%
  select(Blurred_Longitude, Blurred_Latitude, Precinct) %>%
  collect()

df_clustering$Priority <- as.numeric(as.factor(df_clustering$Precinct))

set.seed(123) 

# Scenario 1
eps_value_1 <- 0.5  # Postavka velicine epsilon okoline 
min_samples_1 <- 15  # Minimalan broj 

# Scenario 2
eps_value_2 <- 0.1
min_samples_2 <- 100

df_clustering_scaled <- df_clustering %>%
  mutate(across(everything(), scale))
```

##### Vrsenje klasterizacije prema dva scenarija

``` {r}
#install.packages("dbscan")
library(dbscan)

dbscan_result_1 <- dbscan(df_clustering_scaled, eps = eps_value_1, minPts = min_samples_1)
df_clustering$cluster_scenario_1 <- factor(dbscan_result_1$cluster)

dbscan_result_2 <- dbscan(df_clustering_scaled, eps = eps_value_2, minPts = min_samples_2)

df_clustering$cluster_scenario_2 <- factor(dbscan_result_2$cluster)
```

##### Sumiranje rezultata dva scenarija

``` {r}
# Scenario 1
cluster_summary_1 <- df_clustering %>%
  group_by(cluster_scenario_1) %>%
  summarize(count = n(),
            avg_longitude = mean(Blurred_Longitude),
            avg_latitude = mean(Blurred_Latitude),
            avg_response_time = mean(Response_Time),
            avg_priority = mean(Priority),
            avg_call_type = mean(Call_Type))

# Scenario 2
cluster_summary_2 <- df_clustering %>%
  group_by(cluster_scenario_2) %>%
  summarize(count = n(),
            avg_longitude = mean(Blurred_Longitude),
            avg_latitude = mean(Blurred_Latitude),
            avg_response_time = mean(Response_Time),
            avg_priority = mean(Priority),
            avg_call_type = mean(Call_Type))
```

##### Vizualizacija odnosa obelezja i pripadnosti klasterima

``` {r Scenario 1 - Vizualizacija}
ggplot(data, aes(x = Blurred_Longitude, y = Blurred_Latitude, color = as.factor(Cluster))) +
  geom_point(alpha = 0.6) +
  labs(title = "Lon/Lat and Cluster dependency",
       x = "Blurred Longitude",
       y = "Blurred Latitude",
       color = "Cluster") +
  theme_minimal()
```

``` {r Scenario 2 - Vizualizacija}
ggplot(df_clustering, aes(x = Blurred_Longitude, y = Blurred_Latitude, color = cluster_scenario_2)) +
  geom_point(alpha = 0.6) +
  labs(title = "DBSCAN Clustering (Scenario 2) based on Precinct, Longitude, and Latitude",
       x = "Blurred Longitude",
       y = "Blurred Latitude",
       color = "Cluster") +
  theme_minimal() +
  theme(legend.position = "bottom")
```